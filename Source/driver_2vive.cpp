/*
  PseudoVive
  Copyright (C) 2016-2020 Bernhard Schelling

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.
*/

#define _CRT_SECURE_NO_WARNINGS
#define WIN32_LEAN_AND_MEAN
#define _HAS_EXCEPTIONS 0
#include "MinHook.inl"
#include "openvr_driver.h"

static const char* STR_MANUFACTURERNAME =  "HTC";
static const char* STR_MODELNUMBER_HMD = "Vive MV HTC LHR-00000000";
static const char* STR_MODELNUMBER_TRACKINGREFERENCE = "HTC V2-XD/XE LHB-00000000";
static const char* STR_MODELNUMBER_CONTROLLERLEFT = "Vive Controller MV HTC LHR-00000000";
static const char* STR_MODELNUMBER_CONTROLLERRIGHT = "Vive Controller MV HTC LHR-00000001";

static vr::ETrackedPropertyError (__thiscall *Org_WritePropertyBatch)(vr::IVRProperties* thisptr, vr::PropertyContainerHandle_t ulContainerHandle, vr::PropertyWrite_t *pBatch, uint32_t unBatchEntryCount);

#define USE_SYSTRAY_ICON

#ifdef USE_SYSTRAY_ICON

struct PseudoProperty
{
	vr::IVRProperties* Manager;
	vr::PropertyContainerHandle_t ContainerHandle;
	vr::ETrackedDeviceProperty Prop;
	char BufOrg[128], BufNew[128];
	size_t LenOrg, LenNew;
};

static PseudoProperty PseudoProperties[32];
static size_t PseudoPropertiesCount = 0;

#undef COUNT_OF
#define COUNT_OF(arr) ((sizeof(arr)/sizeof(0[arr]))/((size_t)(!(sizeof(arr) % sizeof(0[arr])))))
#undef MAX
#define MAX(a,b) (((a) > (b)) ? (a) : (b))
#undef MIN
#define MIN(a,b) (((a) < (b)) ? (a) : (b))

#ifdef _M_X64
#define my_memcpy(dest, src, len) __movsb((PBYTE)(dest), (const BYTE*)(src), (SIZE_T)(len))
#else
static inline void my_memcpy(void *dest, const void *src, size_t len) { for (char *d = (char*)dest, *s = (char*)src; len--;*d++ = *s++); }
#endif
static inline void my_memzero(void *dest, size_t len) { for (char *d = (char*)dest; len--;*d++ = 0); }

static void SetupPseudoProperty(vr::IVRProperties* Manager, vr::PropertyContainerHandle_t ContainerHandle, vr::ETrackedDeviceProperty Prop, const void* BufOrg, size_t LenOrg, const void* BufNew, size_t LenNew)
{
	for (PseudoProperty *it = PseudoProperties, *itEnd = it + PseudoPropertiesCount; it != itEnd; it++)
	{
		if (it->Prop != Prop || it->ContainerHandle != ContainerHandle || it->Manager != Manager) continue;
		if (BufOrg) { it->LenOrg = MIN(LenOrg, COUNT_OF(it->BufOrg)); my_memcpy(it->BufOrg, BufOrg, it->LenOrg); }
		if (BufNew) { it->LenNew = MIN(LenNew, COUNT_OF(it->BufNew)); my_memcpy(it->BufNew, BufNew, it->LenNew); }
		return;
	}
	if (PseudoPropertiesCount == COUNT_OF(PseudoProperties)) return;
	PseudoPropertiesCount++;
	PseudoProperty& NewPP = PseudoProperties[PseudoPropertiesCount - 1];
	NewPP.Manager = Manager;
	NewPP.ContainerHandle = ContainerHandle;
	NewPP.Prop = Prop;
	if (BufOrg) { NewPP.LenOrg = MIN(LenOrg, COUNT_OF(NewPP.BufOrg)); my_memcpy(NewPP.BufOrg, BufOrg, NewPP.LenOrg); } else { NewPP.LenOrg = 0; }
	if (BufNew) { NewPP.LenNew = MIN(LenNew, COUNT_OF(NewPP.BufNew)); my_memcpy(NewPP.BufNew, BufNew, NewPP.LenNew); } else { NewPP.LenNew = 0; }
}

static void ApplyPseudoProperties(bool UseOrg)
{
	for (PseudoProperty *it = PseudoProperties, *itEnd = it + PseudoPropertiesCount; it != itEnd; it++)
	{
		vr::PropertyWrite_t batch;
		batch.writeType = vr::PropertyWrite_Set;
		batch.prop = it->Prop;
		batch.pvBuffer = (UseOrg ? it->BufOrg : it->BufNew);
		if (!batch.pvBuffer) continue;
		batch.unBufferSize = (uint32_t)(UseOrg ? it->LenOrg : it->LenNew);
		batch.unTag = vr::k_unStringPropertyTag;
		Org_WritePropertyBatch(it->Manager, it->ContainerHandle, &batch, 1);
	}
}

#include <shellapi.h>
static const unsigned char PNG_VR_ON[885] = { 0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52,0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x10, 0x08, 0x06, 0x00, 0x00, 0x00, 0x1F, 0xF3, 0xFF,0x61, 0x00, 0x00, 0x00, 0x07, 0x74, 0x49, 0x4D, 0x45, 0x07, 0xE2, 0x03, 0x17, 0x0E, 0x27, 0x1B,0x47, 0x08, 0x53, 0x5C, 0x00, 0x00, 0x00, 0x09, 0x70, 0x48, 0x59, 0x73, 0x00, 0x00, 0x0B, 0x12,0x00, 0x00, 0x0B, 0x12, 0x01, 0xD2, 0xDD, 0x7E, 0xFC, 0x00, 0x00, 0x00, 0x04, 0x67, 0x41, 0x4D,0x41, 0x00, 0x00, 0xB1, 0x8F, 0x0B, 0xFC, 0x61, 0x05, 0x00, 0x00, 0x03, 0x04, 0x49, 0x44, 0x41,0x54, 0x78, 0xDA, 0x5D, 0x53, 0x4D, 0x48, 0x55, 0x51, 0x10, 0x9E, 0x39, 0xE7, 0xDC, 0x7B, 0xDF,0x93, 0x67, 0xBD, 0x4C, 0xCD, 0x28, 0x8B, 0x8C, 0x32, 0xAC, 0x1E, 0x92, 0x84, 0x99, 0x14, 0x11,0x26, 0x45, 0x41, 0x1B, 0x21, 0xC2, 0x45, 0x10, 0xD4, 0xA2, 0x68, 0xD1, 0xA2, 0x45, 0x26, 0x54,0x20, 0x44, 0x41, 0x9B, 0x4A, 0x5A, 0x04, 0x81, 0x0B, 0x37, 0x52, 0x10, 0x15, 0x41, 0x65, 0x25,0x14, 0xDA, 0xAF, 0x91, 0x15, 0x91, 0x95, 0x14, 0x95, 0x99, 0xE9, 0x7B, 0xA6, 0xCF, 0xF4, 0xBD,0x7B, 0xCF, 0x99, 0xE6, 0xDC, 0x50, 0xAA, 0x81, 0x39, 0xF7, 0x70, 0x67, 0xE6, 0xFB, 0x66, 0xE6,0xCC, 0x20, 0xFC, 0x25, 0x33, 0x8B, 0x2B, 0xA5, 0x31, 0x41, 0x1E, 0x00, 0x25, 0x58, 0x2B, 0x00,0x30, 0x0E, 0x44, 0xFC, 0xC1, 0x11, 0x36, 0x3F, 0xE3, 0x4B, 0x0F, 0x0A, 0x95, 0x1C, 0xFD, 0xFC,0x48, 0x4F, 0xC5, 0xA0, 0x3D, 0x66, 0x97, 0x6C, 0x40, 0x1D, 0x64, 0x63, 0x86, 0x74, 0x15, 0x90,0x69, 0x24, 0xA4, 0xB5, 0x40, 0x20, 0x10, 0x01, 0x29, 0x74, 0x42, 0x0B, 0x63, 0x90, 0xB0, 0x93,0xEF, 0x4D, 0x28, 0x64, 0x97, 0x54, 0x6E, 0x7A, 0xB8, 0xAF, 0x83, 0xA4, 0x05, 0x88, 0xC6, 0x8B,0x73, 0xD9, 0xAD, 0x9E, 0x00, 0xCF, 0x08, 0x54, 0xA5, 0x52, 0x38, 0x28, 0x84, 0x42, 0x44, 0x05,0x92, 0x55, 0x4C, 0xA9, 0x90, 0xC5, 0x88, 0x72, 0xB3, 0x10, 0x62, 0x98, 0x8D, 0x6F, 0x27, 0x52,0x9F, 0xB2, 0x58, 0xB0, 0xA4, 0x56, 0x92, 0xD1, 0x35, 0x44, 0xBA, 0x85, 0x0D, 0xF9, 0xC6, 0x18,0x0C, 0x39, 0x99, 0xCE, 0xE6, 0xCE, 0xA5, 0x30, 0x85, 0xB0, 0x07, 0xFF, 0x30, 0xA0, 0xC9, 0x1A,0x68, 0x88, 0x81, 0x76, 0x09, 0xA9, 0xDA, 0x65, 0xAC, 0x60, 0x49, 0x3E, 0xA0, 0x3C, 0x87, 0x28,0x4A, 0x39, 0x6B, 0xC1, 0x0E, 0x98, 0xC9, 0xF8, 0xE8, 0x07, 0x36, 0x58, 0x80, 0x31, 0x16, 0x42,0x72, 0xE9, 0x92, 0xAB, 0x43, 0xF0, 0xB3, 0xC4, 0x71, 0x4E, 0x94, 0x8F, 0x45, 0x4C, 0x78, 0x4D,0x71, 0xBA, 0x09, 0xAD, 0x4D, 0x35, 0x83, 0xE8, 0xE2, 0x79, 0x05, 0x62, 0x71, 0xC9, 0x7C, 0x86,0x41, 0x18, 0x18, 0xFC, 0x15, 0x36, 0xC9, 0xCF, 0x8E, 0x52, 0xE0, 0x6B, 0x78, 0xFF, 0xB1, 0x1F,0x66, 0xC4, 0xA2, 0x58, 0x9E, 0x58, 0x06, 0x4F, 0x9E, 0xBF, 0x41, 0x1B, 0xC3, 0xBD, 0x48, 0xC8,0xF8, 0x9C, 0x15, 0x75, 0xDA, 0xE0, 0x26, 0x66, 0x33, 0x37, 0xDB, 0x4E, 0xC9, 0x9A, 0xF5, 0x15,0xB8, 0x72, 0xE9, 0x22, 0x28, 0x2B, 0x29, 0xC2, 0x47, 0x2F, 0x3E, 0x40, 0xF3, 0xF1, 0x7D, 0x58,0x98, 0x37, 0x13, 0xEF, 0x3D, 0x78, 0x09, 0xB5, 0xEB, 0x57, 0xC3, 0x91, 0x03, 0xF5, 0x70, 0xE5,0xF6, 0x63, 0xF4, 0x7D, 0xE2, 0x3E, 0x89, 0xD7, 0x82, 0xD0, 0x99, 0x25, 0x9D, 0x08, 0xB2, 0x3A,0x96, 0xF1, 0x44, 0xF3, 0x75, 0x38, 0x74, 0xF8, 0x3C, 0x6C, 0xDD, 0x52, 0x1D, 0x66, 0xF0, 0xF5,0xC7, 0x08, 0xAC, 0xA9, 0x58, 0x0E, 0x73, 0x0B, 0x0B, 0xE1, 0xE0, 0xDE, 0x3A, 0xBC, 0x75, 0xE7,0x29, 0x4E, 0x4C, 0x68, 0x4E, 0xD8, 0xE1, 0x3E, 0xBA, 0xB3, 0xB8, 0xB1, 0x1E, 0x70, 0x30, 0xBB,0x3A, 0xBE, 0x0D, 0xD8, 0xB1, 0xBD, 0x12, 0x5A, 0x2E, 0x36, 0xE0, 0x8B, 0x9E, 0x0F, 0x30, 0x36,0xEE, 0x43, 0xD3, 0xC9, 0xD6, 0x10, 0x68, 0x63, 0x75, 0x39, 0xBF, 0x23, 0xD2, 0xC3, 0x57, 0x9F,0xC0, 0xD7, 0x12, 0x6C, 0x1C, 0x28, 0x0F, 0x94, 0xF1, 0xA2, 0x29, 0xEE, 0x15, 0x39, 0xD2, 0x0F,0x33, 0x68, 0xBB, 0xFA, 0x18, 0x6E, 0x76, 0x3C, 0x85, 0xFF, 0x65, 0xF7, 0xCE, 0x1A, 0xFC, 0x36,0x38, 0x42, 0xBD, 0xDF, 0x53, 0x64, 0xA2, 0x11, 0x30, 0x4A, 0xF2, 0xCB, 0x88, 0x94, 0x30, 0xAE,0xD3, 0xAD, 0x73, 0xA2, 0x14, 0x44, 0x22, 0x94, 0xFC, 0x31, 0x46, 0x56, 0xEC, 0xFD, 0x6F, 0x3D,0xDD, 0x7A, 0x97, 0x56, 0x96, 0x2D, 0xA4, 0x4B, 0xB7, 0xBB, 0x21, 0x95, 0xE1, 0x21, 0x8C, 0xE5,0x90, 0xCE, 0x89, 0x90, 0xF6, 0x9C, 0x6E, 0x99, 0x5B, 0xBA, 0x2E, 0x0D, 0x9E, 0x57, 0x05, 0xAE,0xB7, 0xE0, 0xDD, 0xF7, 0x24, 0xF4, 0x8D, 0x4E, 0xC2, 0x4F, 0xEB, 0xE4, 0x79, 0xD3, 0x3A, 0x3C,0x99, 0x81, 0xAE, 0x37, 0x5F, 0xE0, 0x2D, 0xB3, 0x0F, 0x65, 0x7D, 0x44, 0xC7, 0x25, 0x50, 0x4E,0x27, 0x2A, 0x71, 0x16, 0x8B, 0xB6, 0x35, 0x48, 0x74, 0x9C, 0x1A, 0x29, 0xB1, 0xC5, 0x10, 0xE6,0x0B, 0xE4, 0x4A, 0xED, 0xFB, 0xDB, 0x69, 0x22, 0x3B, 0x51, 0x61, 0x05, 0x7F, 0x06, 0x89, 0x0C,0xFF, 0x17, 0x24, 0x90, 0x86, 0xB4, 0xA6, 0x5D, 0x14, 0x04, 0xED, 0x32, 0xDD, 0x7B, 0x9F, 0xE2,0xAB, 0xB6, 0x0C, 0x82, 0xE3, 0x26, 0xD1, 0xF3, 0x2A, 0xB9, 0x31, 0x51, 0xF4, 0x5C, 0x9E, 0x62,0xD7, 0x32, 0xC1, 0xBF, 0xEA, 0x91, 0x70, 0xDD, 0x61, 0x90, 0xEA, 0x98, 0x50, 0xEA, 0x46, 0xFF,0xE5, 0xA3, 0x93, 0x2A, 0x84, 0x0F, 0x4C, 0x1A, 0x62, 0xD1, 0x56, 0x2D, 0x65, 0x1F, 0x4F, 0x64,0x23, 0x6F, 0xE0, 0xDA, 0x3F, 0x8B, 0x66, 0xC2, 0x69, 0xB4, 0x2E, 0x76, 0x20, 0x79, 0xBB, 0x3A,0x89, 0x4C, 0x93, 0xD4, 0xBA, 0x0B, 0xD2, 0xE3, 0xE9, 0xE9, 0x6D, 0x9C, 0x92, 0xA2, 0x3D, 0xCD,0x92, 0x6B, 0xCE, 0x33, 0x42, 0x25, 0xF8, 0x91, 0x2B, 0xD8, 0x1A, 0xE7, 0x9E, 0xDA, 0x8D, 0x18,0xE1, 0x22, 0x9E, 0x61, 0x10, 0xF4, 0x40, 0x36, 0x93, 0x1C, 0xB8, 0xB0, 0x7F, 0x7A, 0x9D, 0x7F,0x03, 0x88, 0x4C, 0x43, 0xAC, 0xE5, 0xBA, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E,0x44, 0xAE, 0x42, 0x60, 0x82 };
static const unsigned char PNG_VR_OFF[819] = { 0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x10, 0x08, 0x06, 0x00, 0x00, 0x00, 0x1F, 0xF3, 0xFF, 0x61, 0x00, 0x00, 0x00, 0x07, 0x74, 0x49, 0x4D, 0x45, 0x07, 0xE2, 0x03, 0x17, 0x0E, 0x28, 0x24, 0x76, 0xF6, 0x62, 0xAE, 0x00, 0x00, 0x00, 0x09, 0x70, 0x48, 0x59, 0x73, 0x00, 0x00, 0x0B, 0x12, 0x00, 0x00, 0x0B, 0x12, 0x01, 0xD2, 0xDD, 0x7E, 0xFC, 0x00, 0x00, 0x00, 0x04, 0x67, 0x41, 0x4D, 0x41, 0x00, 0x00, 0xB1, 0x8F, 0x0B, 0xFC, 0x61, 0x05, 0x00, 0x00, 0x02, 0xC2, 0x49, 0x44, 0x41, 0x54, 0x78, 0xDA, 0x95, 0x53, 0x4F, 0x48, 0x95, 0x41, 0x10, 0x9F, 0xD9, 0xDD, 0xEF, 0xFB, 0x7C, 0xF2, 0xCC, 0x87, 0x69, 0x09, 0x66, 0xA1, 0x61, 0x86, 0xE8, 0x23, 0x92, 0x10, 0x8D, 0xA4, 0x83, 0x49, 0x41, 0xC7, 0xA0, 0x83, 0x07, 0x4F, 0x5D, 0x8A, 0x6E, 0x41, 0x54, 0x82, 0x05, 0x52, 0x11, 0x74, 0xE8, 0x8F, 0x41, 0x74, 0xF2, 0xE0, 0x45, 0x0C, 0x02, 0x31, 0x10, 0x25, 0x85, 0x42, 0xB3, 0xD2, 0xC8, 0x0A, 0xB1, 0x3F, 0x52, 0x14, 0xE6, 0x9F, 0xE7, 0x7B, 0x6A, 0xAF, 0xF2, 0xBD, 0xEF, 0xDB, 0x9D, 0x66, 0x9F, 0x28, 0x75, 0x74, 0x60, 0x76, 0x97, 0x9D, 0x99, 0xDF, 0xEC, 0xFC, 0x76, 0x06, 0xE1, 0x1F, 0xC9, 0x2D, 0xAE, 0x91, 0xC6, 0x04, 0x79, 0x00, 0x14, 0x65, 0xAD, 0x06, 0xC0, 0x08, 0x10, 0xF1, 0x86, 0x4B, 0x6C, 0x1E, 0xE3, 0xC3, 0x04, 0x0A, 0x15, 0x5F, 0xF9, 0x36, 0xAA, 0xD7, 0x63, 0xD0, 0x2E, 0x5B, 0x4B, 0x0F, 0xA3, 0x0E, 0xD2, 0x61, 0x43, 0xBA, 0x16, 0xC8, 0xB4, 0x10, 0x52, 0x1D, 0x10, 0x08, 0x44, 0x40, 0xCA, 0x38, 0xA1, 0x85, 0x31, 0x48, 0x38, 0xCC, 0xE7, 0x36, 0x14, 0x72, 0x44, 0x2A, 0x37, 0xB9, 0x38, 0x3D, 0x44, 0xD2, 0x02, 0x84, 0x22, 0xC5, 0x39, 0xEC, 0xD6, 0x44, 0x80, 0xB7, 0x05, 0xAA, 0x72, 0x29, 0x1C, 0x14, 0x42, 0x21, 0xA2, 0x02, 0xC9, 0x2A, 0xD6, 0x55, 0xC8, 0x62, 0x44, 0x79, 0x54, 0x08, 0xB1, 0xC8, 0xC6, 0xA9, 0x3F, 0x89, 0xAF, 0x69, 0x2C, 0x28, 0x6B, 0x94, 0x64, 0x74, 0x03, 0x91, 0xEE, 0x60, 0x43, 0xBE, 0x31, 0x06, 0x33, 0x39, 0x39, 0x9D, 0x7D, 0x3B, 0x97, 0xC2, 0x29, 0x84, 0x5D, 0xF8, 0xC2, 0x80, 0x26, 0x6B, 0xA0, 0x18, 0x03, 0x35, 0x0B, 0xA9, 0x06, 0x64, 0xB8, 0xA0, 0x2C, 0x1F, 0x50, 0xDE, 0x45, 0x14, 0xE5, 0xFC, 0x6A, 0xC1, 0x0E, 0x98, 0x4A, 0xF9, 0xE8, 0x07, 0x36, 0x58, 0x80, 0x31, 0x16, 0x42, 0x72, 0xE9, 0x92, 0xAB, 0x43, 0xF0, 0xD3, 0xC4, 0x71, 0x4E, 0x88, 0x97, 0x12, 0x4E, 0xD8, 0xA3, 0xF8, 0xB9, 0x51, 0xAD, 0xCD, 0x41, 0x06, 0xD1, 0xC5, 0x45, 0x05, 0x62, 0x77, 0xE9, 0x0E, 0x86, 0x41, 0x98, 0x9D, 0xFF, 0x9D, 0x21, 0xC9, 0x4F, 0xAF, 0x50, 0xE0, 0x6B, 0xF8, 0xF4, 0x65, 0x06, 0xB6, 0x84, 0x43, 0xB8, 0x2F, 0xBA, 0x17, 0x5E, 0xBE, 0x9E, 0x44, 0x1B, 0xC3, 0x5C, 0x44, 0x65, 0x64, 0x7B, 0xE5, 0x09, 0x6D, 0xF0, 0x08, 0x67, 0x33, 0x7D, 0x5D, 0x37, 0x64, 0x43, 0x7D, 0x35, 0x56, 0xED, 0x29, 0x81, 0x8A, 0xD2, 0x42, 0x1C, 0x7D, 0xF3, 0x19, 0xDA, 0xAF, 0x9C, 0xC6, 0x6D, 0x79, 0xB9, 0x38, 0xF8, 0xEC, 0x2D, 0x34, 0xD6, 0x1F, 0x80, 0x4B, 0x67, 0x9B, 0xE0, 0x51, 0xFF, 0x0B, 0xF4, 0x7D, 0x62, 0x9E, 0xC4, 0x7B, 0x2C, 0xAA, 0x3C, 0x79, 0xD5, 0x10, 0x5C, 0xB0, 0x59, 0x37, 0x2B, 0xCC, 0xD4, 0x35, 0x25, 0xA4, 0xC7, 0x54, 0x21, 0x6C, 0x3E, 0xDC, 0xB2, 0x8A, 0xA0, 0x8C, 0x17, 0x4A, 0x30, 0x57, 0x24, 0x7C, 0x1F, 0x07, 0xBB, 0x5A, 0xE1, 0xFA, 0xBD, 0xDE, 0x0D, 0x87, 0xBE, 0xA1, 0x57, 0x99, 0xBD, 0xE7, 0xFE, 0xB9, 0xCC, 0xFE, 0x63, 0x61, 0x99, 0xCE, 0xDF, 0xEA, 0x86, 0xD9, 0xD8, 0x32, 0x28, 0x65, 0x3B, 0x40, 0x24, 0x84, 0x71, 0x9D, 0x71, 0x9D, 0x1D, 0xA2, 0x20, 0x2B, 0x8B, 0xE2, 0x0B, 0x3F, 0xC9, 0x4A, 0xEF, 0xF3, 0x77, 0x19, 0xB5, 0x77, 0x56, 0x6F, 0x76, 0x3E, 0xA1, 0xAA, 0x8A, 0x5D, 0xD4, 0xDD, 0x3F, 0x0E, 0x89, 0x14, 0x37, 0x61, 0x38, 0x9B, 0x74, 0x76, 0x16, 0x69, 0xCF, 0x19, 0x97, 0x39, 0xE5, 0x87, 0x92, 0xE0, 0x79, 0xB5, 0xE0, 0x7A, 0x3B, 0x3F, 0xCE, 0xC5, 0x61, 0x7A, 0x65, 0x15, 0x96, 0xAD, 0x93, 0xE7, 0x6D, 0xE8, 0xE2, 0x6A, 0x0A, 0x46, 0x26, 0xBF, 0xC3, 0xD4, 0x5C, 0x82, 0x62, 0x69, 0x1F, 0xD1, 0x71, 0x09, 0x94, 0x33, 0x8C, 0x4A, 0xDC, 0xC1, 0xC2, 0xE3, 0x17, 0x25, 0x3A, 0x4E, 0x83, 0x94, 0xD8, 0x61, 0x08, 0xF3, 0x05, 0x1A, 0xAE, 0x8C, 0xFF, 0xDF, 0x72, 0x44, 0xB0, 0x4E, 0xCE, 0x5A, 0x23, 0x91, 0xE1, 0x7B, 0x41, 0x02, 0x29, 0xA6, 0x35, 0x35, 0x53, 0x10, 0x0C, 0xC8, 0xE4, 0x87, 0xA7, 0x14, 0xD9, 0x7F, 0x6C, 0x1E, 0x1C, 0x37, 0x8E, 0x9E, 0x57, 0x03, 0xCA, 0x0B, 0xA1, 0xE7, 0x72, 0x17, 0xBB, 0x36, 0x13, 0xFC, 0xAF, 0x1E, 0x09, 0xD7, 0x5D, 0x04, 0xA9, 0x2E, 0x0B, 0xA5, 0x1E, 0xCF, 0x3C, 0x6C, 0x5D, 0x55, 0x19, 0xF8, 0xC0, 0x24, 0x21, 0x1C, 0xEA, 0xD4, 0x52, 0x4E, 0x73, 0x47, 0xB6, 0xF0, 0x04, 0xD6, 0xAD, 0x0D, 0x9A, 0xC9, 0x74, 0xA3, 0x75, 0xB1, 0x0D, 0xC9, 0xD3, 0x35, 0x4C, 0x64, 0xDA, 0xA4, 0xD6, 0x23, 0x90, 0xFC, 0x95, 0xDC, 0x98, 0xC6, 0x75, 0x29, 0x3C, 0xD5, 0x2E, 0xB9, 0xE6, 0x3C, 0x23, 0x54, 0x94, 0xBF, 0xB6, 0x9A, 0xAD, 0x11, 0xE6, 0xD4, 0x4E, 0xC4, 0x12, 0x17, 0x31, 0x86, 0x41, 0x30, 0x01, 0xE9, 0x54, 0x7C, 0xF6, 0xC1, 0x99, 0x8D, 0x71, 0xFE, 0x0B, 0x12, 0x97, 0x2A, 0xFC, 0xE7, 0xB9, 0x4B, 0x58, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82 };
static HWND g_SystrayHWND;
static bool g_ACTIVE = true;

static DWORD CALLBACK SystrayThread(LPVOID)
{
	static HICON s_ICON;
	struct Wnd
	{
		static void UpdateIcon(HWND hWnd, DWORD NIM_MSG)
		{
			NOTIFYICONDATAA nid;
			my_memzero(&nid, sizeof(nid));
			nid.cbSize = sizeof(nid); 
			nid.hWnd = hWnd;
			nid.uFlags = NIF_ICON | NIF_MESSAGE | NIF_TIP;
			HICON OldICON = s_ICON;
			nid.hIcon = s_ICON = (NIM_MSG == NIM_DELETE ? 0 : CreateIconFromResourceEx((PBYTE)(g_ACTIVE ? PNG_VR_ON : PNG_VR_OFF), (g_ACTIVE ? sizeof(PNG_VR_ON) : sizeof(PNG_VR_OFF)), 1, 0x30000, 32, 32, LR_DEFAULTCOLOR));
			nid.uCallbackMessage = WM_USER; 
			strcpy(nid.szTip, /*sizeof(nid.szTip), */"Minimal Systray");
			Shell_NotifyIconA(NIM_MSG, &nid);
			if (OldICON) DestroyIcon(OldICON);
		}
		static LRESULT CALLBACK Proc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
		{
			enum EButtons { IDM_NONE, IDM_ACTIVE };
			static UINT s_WM_TASKBARRESTART;
			if (Msg == WM_COMMAND && wParam == IDM_ACTIVE)
			{
				g_ACTIVE ^= 1;
				if (g_ACTIVE) ApplyPseudoProperties(false);
				else ApplyPseudoProperties(true);
				UpdateIcon(hWnd, NIM_MODIFY);
			}
			if (Msg == WM_USER && (LOWORD(lParam) == WM_LBUTTONUP || LOWORD(lParam) == WM_RBUTTONUP))
			{
				HMENU hPopMenu = CreatePopupMenu();
				InsertMenuA(hPopMenu,0xFFFFFFFF,MF_STRING|MF_GRAYED,IDM_NONE, "Pseudo Vive");
				InsertMenuA(hPopMenu,0xFFFFFFFF,MF_SEPARATOR,IDM_NONE,NULL);
				InsertMenuA(hPopMenu,0xFFFFFFFF,MF_STRING|(g_ACTIVE ? MF_CHECKED : MF_UNCHECKED),IDM_ACTIVE,"Is Active");
				SetForegroundWindow(hWnd); //cause the popup to be focused
				POINT lpClickPoint;
				GetCursorPos(&lpClickPoint);
				TrackPopupMenu(hPopMenu,TPM_LEFTALIGN|TPM_LEFTBUTTON|TPM_BOTTOMALIGN, lpClickPoint.x, lpClickPoint.y,0,hWnd,NULL);
			}
			if (Msg == WM_CREATE || Msg == s_WM_TASKBARRESTART)
			{
				if (Msg == WM_CREATE) s_WM_TASKBARRESTART = RegisterWindowMessageA("TaskbarCreated");
				g_SystrayHWND = hWnd;
				UpdateIcon(hWnd, NIM_ADD);
			}
			if (Msg == WM_DESTROY)
			{
				UpdateIcon(hWnd, NIM_DELETE);
			}
			return DefWindowProcA(hWnd, Msg, wParam, lParam);
		}
	};
	MSG Msg;
	WNDCLASSA c;
	ZeroMemory(&c, sizeof(c));
	c.lpfnWndProc = Wnd::Proc;
	c.hInstance = GetModuleHandleA(NULL);
	c.lpszClassName = "PSEUDOVIVE";
	if (!RegisterClassA(&c) || !CreateWindowA(c.lpszClassName, 0, 0, 0, 0, 0, 0, 0, 0, c.hInstance, 0)) return 1;
	while (GetMessageA(&Msg, 0, 0, 0) > 0) { TranslateMessage(&Msg); DispatchMessageA(&Msg); }
	return 0;
}

#endif

struct HookVirtualFunctions
{
	enum { VFTIDX_WRITEPROPERTYBATCH };

	virtual vr::ETrackedPropertyError WritePropertyBatch(vr::PropertyContainerHandle_t ulContainerHandle, vr::PropertyWrite_t *pBatch, uint32_t unBatchEntryCount)
	{
		vr::IVRProperties* self = (vr::IVRProperties*)this;

		bool bUpdateModelNumber = false;
		#ifdef USE_SYSTRAY_ICON
		bool bUpdatePseudoProperties = false;
		#endif

		for (vr::PropertyWrite_t *it = pBatch, *itEnd = it + unBatchEntryCount; it != itEnd; it++)
		{
			if (it->writeType != vr::PropertyWrite_Set) continue;
			#ifdef USE_SYSTRAY_ICON
			if (it->prop == vr::Prop_ManufacturerName_String)
			{
				SetupPseudoProperty(self, ulContainerHandle, it->prop, it->pvBuffer, it->unBufferSize, STR_MANUFACTURERNAME, strlen(STR_MANUFACTURERNAME) + 1);
				bUpdatePseudoProperties = true;
			}
			if (it->prop == vr::Prop_ModelNumber_String) SetupPseudoProperty(self, ulContainerHandle, it->prop, it->pvBuffer, it->unBufferSize, NULL, 0);
			#else
			if (it->prop == vr::Prop_ManufacturerName_String) { it->pvBuffer = (void*)STR_MANUFACTURERNAME; it->unBufferSize = (uint32_t)strlen(STR_MANUFACTURERNAME) + 1; }
			#endif
			if (it->prop == vr::Prop_ModelNumber_String || it->prop == vr::Prop_DeviceClass_Int32 || it->prop == vr::Prop_ControllerRoleHint_Int32) bUpdateModelNumber = true;
		}

		if (bUpdateModelNumber)
		{
			vr::PropertyWrite_t* PropertyModelNumber = NULL;
			vr::ETrackedDeviceClass DeviceClass = vr::TrackedDeviceClass_Invalid;
			vr::ETrackedControllerRole ControllerRole = vr::TrackedControllerRole_Invalid;
			for (vr::PropertyWrite_t *it = pBatch, *itEnd = it + unBatchEntryCount; it != itEnd; it++)
			{
				if (it->writeType != vr::PropertyWrite_Set) continue;
				else if (it->prop == vr::Prop_ModelNumber_String) PropertyModelNumber = it;
				else if (it->prop == vr::Prop_DeviceClass_Int32) DeviceClass = *(vr::ETrackedDeviceClass*)it->pvBuffer;
				else if (it->prop == vr::Prop_ControllerRoleHint_Int32) ControllerRole = *(vr::ETrackedControllerRole*)it->pvBuffer;
			}
			if (DeviceClass == vr::TrackedDeviceClass_Invalid) DeviceClass = (vr::ETrackedDeviceClass)vr::CVRPropertyHelpers(self).GetInt32Property(ulContainerHandle, vr::Prop_DeviceClass_Int32);
			if (ControllerRole == vr::TrackedControllerRole_Invalid && DeviceClass == vr::TrackedDeviceClass_Controller) ControllerRole = (vr::ETrackedControllerRole)vr::CVRPropertyHelpers(self).GetInt32Property(ulContainerHandle, vr::Prop_ControllerRoleHint_Int32);

			const char* str = STR_MODELNUMBER_HMD;
			if      (DeviceClass == vr::TrackedDeviceClass_TrackingReference)                                                   str = STR_MODELNUMBER_TRACKINGREFERENCE;
			else if (DeviceClass == vr::TrackedDeviceClass_Controller && ControllerRole == vr::TrackedControllerRole_RightHand) str = STR_MODELNUMBER_CONTROLLERRIGHT;
			else if (DeviceClass == vr::TrackedDeviceClass_Controller)                                                          str = STR_MODELNUMBER_CONTROLLERLEFT;

			#ifdef USE_SYSTRAY_ICON
			SetupPseudoProperty(self, ulContainerHandle, vr::Prop_ModelNumber_String, NULL, 0, str, strlen(str) + 1);
			bUpdatePseudoProperties = true;
			#else
			if (PropertyModelNumber) { PropertyModelNumber->pvBuffer = (void*)str; PropertyModelNumber->unBufferSize = (uint32_t)strlen(str) + 1; }
			else
			{
				vr::PropertyWrite_t batch;
				batch.writeType = vr::PropertyWrite_Set;
				batch.prop = vr::Prop_ModelNumber_String;
				batch.pvBuffer = (void*)str;
				batch.unBufferSize = (uint32_t)strlen(str) + 1;
				batch.unTag = vr::k_unStringPropertyTag;
				Org_WritePropertyBatch(self, ulContainerHandle, &batch, 1);
			}
			#endif
		}

		vr::ETrackedPropertyError res = Org_WritePropertyBatch(self, ulContainerHandle, pBatch, unBatchEntryCount);
		#ifdef USE_SYSTRAY_ICON
		if (bUpdatePseudoProperties && g_ACTIVE) ApplyPseudoProperties(false);
		#endif
		return res;
	}

	static void Hook(void* Object, int ObjectVFTIdx, int OurVFTIdx, void** Out_OriginalFunction)
	{
		const HookVirtualFunctions DummyHookVirtualFunctions;
		void *TrackedDeviceAddedFunc = (*(void***)Object)[ObjectVFTIdx], *Our_TrackedDeviceAdded = (*(void***)&DummyHookVirtualFunctions)[OurVFTIdx];
		MH_STATUS StatusCreate = MH_CreateHook(TrackedDeviceAddedFunc, Our_TrackedDeviceAdded, Out_OriginalFunction);
		if      (StatusCreate == MH_ERROR_ALREADY_CREATED)       { MessageBoxA(NULL, "MH_CreateHook failed", "PseudoVive Error", 0); }
		else if (StatusCreate != MH_OK)                          { MessageBoxA(NULL, "MH_CreateHook failed", "PseudoVive Error", 0); }
		else if (MH_EnableHook(TrackedDeviceAddedFunc) != MH_OK) { MessageBoxA(NULL, "MH_EnableHook failed", "PseudoVive Error", 0); }
	}
};

struct CServerTrackedDeviceProvider : public vr::IServerTrackedDeviceProvider
{
	virtual vr::EVRInitError Init(vr::IVRDriverContext *pDriverContext)
	{
		VR_INIT_SERVER_DRIVER_CONTEXT(pDriverContext);

		//initialize minhook
		if (MH_Initialize() != MH_OK) { MessageBoxA(NULL, "MH_Initialize failed", "PseudoVive Error", 0); return vr::VRInitError_None; }

		//We hook the 2nd function in the virtual function table of vr::IVRProperties (WritePropertyBatch)
		HookVirtualFunctions::Hook(vr::VRPropertiesRaw(), 1, HookVirtualFunctions::VFTIDX_WRITEPROPERTYBATCH, (void**)&Org_WritePropertyBatch);

		#ifdef USE_SYSTRAY_ICON
		CreateThread(NULL, 0, SystrayThread, NULL, 0, NULL);
		#endif

		return vr::VRInitError_None;
	}
	virtual void Cleanup()
	{
		VR_CLEANUP_SERVER_DRIVER_CONTEXT();
		#ifdef USE_SYSTRAY_ICON
		SendMessageA(g_SystrayHWND, WM_DESTROY, 0, 0);
		#endif
	}
	virtual const char * const * GetInterfaceVersions() { static const char * const Versions[] = { vr::ITrackedDeviceServerDriver_Version, NULL }; return Versions; }
	virtual void RunFrame() { }
	virtual bool ShouldBlockStandbyMode() { return false; }
	virtual void EnterStandby() { }
	virtual void LeaveStandby() { }
};

#if _MSC_VER < 1900
// Older Visual Studio versions were perfectly fine with using _DllMainCRTStartup as the entry point.
// This avoids linking against the CRT and reduces the output binary size from 110kb to 20kb.
extern "C" BOOL __stdcall _DllMainCRTStartup(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)
#else
// Starting with Visual Studio 2015 it now needs to be linked against the Microsoft C runtime.
// This bloats the output DLL file size to over 500% of what a build with an older linker could produce.
extern "C" BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)
#endif
{
	if (fdwReason == DLL_PROCESS_ATTACH)
	{
		//add reference to self so we are kept loaded in the vr server process
		WCHAR modname[MAX_PATH];
		GetModuleFileNameW(hinstDLL, modname, MAX_PATH);
		LoadLibraryW(modname);
	}
	return TRUE;
}

extern "C" __declspec(dllexport) void *HmdDriverFactory(const char *pInterfaceName, int *pReturnCode)
{
	//manual string compare to keep number of linked libraries low
	size_t Len = (pInterfaceName ? strlen(pInterfaceName) : 0), Len2 = strlen(vr::IServerTrackedDeviceProvider_Version);
	if (Len != Len2) return NULL;
	for (size_t i = 0; i != Len && i <= Len; i++) if (pInterfaceName[i] != vr::IServerTrackedDeviceProvider_Version[i]) return NULL;
	static CServerTrackedDeviceProvider Server;
	return &Server;
}

extern "C" int _purecall() { return 0; }
